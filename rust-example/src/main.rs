use aes_gcm::{aead::Aead, Aes256Gcm, Error, Key, KeyInit, Nonce};
use anyhow::bail;
use rand::{distributions::Alphanumeric, thread_rng, Rng, RngCore};

fn generate_utf8_key() -> String {
    let mut rng = thread_rng();

    // Generate a string of 32 characters using the Alphanumeric distribution
    let key: String = (0..32).map(|_| rng.sample(Alphanumeric) as char).collect();
    
    return key;
}

fn main() {
    let key = generate_utf8_key();

    let message = "Superman is Clark Kent!";

    let (encrypted, nonce) = match encrypt(message, key.as_bytes()) {
        Ok(val) => {
            val
        }, 
        Err(err) => {
            panic!("Failed to encrypt. {}", err);
        }
    };
    
    let decrypted_message = match decrypt(key.as_bytes(), &nonce, encrypted.as_slice()) {
        Ok(val) => { 
            val
        }, 
        Err(err) => { 
            panic!("Failed to decrypt: {}", err);
        } 
    };
    
    println!("Decrypted message: {}", decrypted_message);
}

/// The length of the key determines what type of the AES encryption.
fn encrypt(plaintext: &str, key: &[u8]) -> Result<(Vec<u8>, Vec<u8>), Error> {
    let key = Key::<Aes256Gcm>::from_slice(key); // Create key from provided slice

    // Generate a new nonce
    let mut nonce_bytes = [0u8; 12]; // AES-GCM nonce must be 12 bytes
    rand::thread_rng().fill_bytes(&mut nonce_bytes); // Fill nonce with random bytes
    let nonce = Nonce::from_slice(&nonce_bytes); // Create nonce from generated bytes

    let cipher = Aes256Gcm::new(key); // Create the AES GCM cipher

    // Encrypt the plaintext and return the resulting ciphertext along with the nonce
    let ciphertext = cipher.encrypt(nonce, plaintext.as_bytes())?;

    return Ok((ciphertext, nonce_bytes.to_vec()));
}

fn decrypt(key: &[u8], nonce: &[u8], ciphertext: &[u8]) -> anyhow::Result<String> {
    use aes_gcm::{Aes256Gcm, Key, Nonce, aead::Aead};
    
    let key = Key::<Aes256Gcm>::from_slice(&key);
    let nonce = Nonce::from_slice(&nonce);

    let cipher = Aes256Gcm::new(key);
    let plaintext = match cipher.decrypt(nonce, ciphertext) { 
        Ok(val) => { 
            val
        }, 
        Err(err) => { 
            bail!("Failed to decrypt. {}", err);
        } 
    };
    
    let plaintext = String::from_utf8(plaintext)?;
    
    return Ok(plaintext);
}
